// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const getCanonicalID = `-- name: GetCanonicalID :one
select canonical_id from entities
 where id = ?
`

func (q *Queries) GetCanonicalID(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getCanonicalID, id)
	var canonical_id string
	err := row.Scan(&canonical_id)
	return canonical_id, err
}

const getEntityByCanonicalID = `-- name: GetEntityByCanonicalID :one
select id, canonical_id from entities
where canonical_id = ?
`

func (q *Queries) GetEntityByCanonicalID(ctx context.Context, canonicalID string) (Entity, error) {
	row := q.db.QueryRowContext(ctx, getEntityByCanonicalID, canonicalID)
	var i Entity
	err := row.Scan(&i.ID, &i.CanonicalID)
	return i, err
}

const getEntityID = `-- name: GetEntityID :one
select id from entities
 where canonical_id = ?
`

func (q *Queries) GetEntityID(ctx context.Context, canonicalID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getEntityID, canonicalID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertEntity = `-- name: InsertEntity :one
insert into entities(canonical_id)
values (?)
returning id
`

func (q *Queries) InsertEntity(ctx context.Context, canonicalID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertEntity, canonicalID)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertHeartbeat = `-- name: InsertHeartbeat :one
insert into heartbeat(entity_id, ts, successful, error)
values (?, ?, ?, ?)
returning id
`

type InsertHeartbeatParams struct {
	EntityID   int64
	Ts         time.Time
	Successful bool
	Error      sql.NullString
}

func (q *Queries) InsertHeartbeat(ctx context.Context, arg InsertHeartbeatParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertHeartbeat,
		arg.EntityID,
		arg.Ts,
		arg.Successful,
		arg.Error,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const insertMetrics = `-- name: InsertMetrics :one
insert into metrics(entity_id, ts, name, type, value, labels)
values (?, ?, ?, ?, ?, ?)
returning id
`

type InsertMetricsParams struct {
	EntityID int64
	Ts       time.Time
	Name     string
	Type     string
	Value    float64
	Labels   json.RawMessage
}

func (q *Queries) InsertMetrics(ctx context.Context, arg InsertMetricsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertMetrics,
		arg.EntityID,
		arg.Ts,
		arg.Name,
		arg.Type,
		arg.Value,
		arg.Labels,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const listEntities = `-- name: ListEntities :many
select id, canonical_id from entities
order by id
`

func (q *Queries) ListEntities(ctx context.Context) ([]Entity, error) {
	rows, err := q.db.QueryContext(ctx, listEntities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Entity
	for rows.Next() {
		var i Entity
		if err := rows.Scan(&i.ID, &i.CanonicalID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listHeartbeats = `-- name: ListHeartbeats :many
select h.id, h.entity_id, h.ts, h.successful, h.error, e.canonical_id
from heartbeat h
join entities e on h.entity_id = e.id
where (e.canonical_id = ?1 or ?1 is null)
  and (h.ts >= ?2 or ?2 is null)
  and (h.ts <= ?3 or ?3 is null)
  and (h.successful = ?4 or ?4 is null)
order by h.ts desc
limit ?5 offset ?6
`

type ListHeartbeatsParams struct {
	CanonicalID string
	Ts          time.Time
	Ts_2        time.Time
	Successful  bool
	Limit       int64
	Offset      int64
}

type ListHeartbeatsRow struct {
	ID          int64
	EntityID    int64
	Ts          time.Time
	Successful  bool
	Error       sql.NullString
	CanonicalID string
}

func (q *Queries) ListHeartbeats(ctx context.Context, arg ListHeartbeatsParams) ([]ListHeartbeatsRow, error) {
	rows, err := q.db.QueryContext(ctx, listHeartbeats,
		arg.CanonicalID,
		arg.Ts,
		arg.Ts_2,
		arg.Successful,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListHeartbeatsRow
	for rows.Next() {
		var i ListHeartbeatsRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityID,
			&i.Ts,
			&i.Successful,
			&i.Error,
			&i.CanonicalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMetrics = `-- name: ListMetrics :many
select m.id, m.entity_id, m.ts, m.name, m.type, m.value, m.labels, e.canonical_id
from metrics m
join entities e on m.entity_id = e.id
where (e.canonical_id = ?1 or ?1 is null)
  and (m.ts >= ?2 or ?2 is null)
  and (m.ts <= ?3 or ?3 is null)
  and (m.name = ?4 or ?4 is null)
  and (m.type = ?5 or ?5 is null)
order by m.ts desc
limit ?6 offset ?7
`

type ListMetricsParams struct {
	CanonicalID string
	Ts          time.Time
	Ts_2        time.Time
	Name        string
	Type        string
	Limit       int64
	Offset      int64
}

type ListMetricsRow struct {
	ID          int64
	EntityID    int64
	Ts          time.Time
	Name        string
	Type        string
	Value       float64
	Labels      json.RawMessage
	CanonicalID string
}

func (q *Queries) ListMetrics(ctx context.Context, arg ListMetricsParams) ([]ListMetricsRow, error) {
	rows, err := q.db.QueryContext(ctx, listMetrics,
		arg.CanonicalID,
		arg.Ts,
		arg.Ts_2,
		arg.Name,
		arg.Type,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListMetricsRow
	for rows.Next() {
		var i ListMetricsRow
		if err := rows.Scan(
			&i.ID,
			&i.EntityID,
			&i.Ts,
			&i.Name,
			&i.Type,
			&i.Value,
			&i.Labels,
			&i.CanonicalID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

